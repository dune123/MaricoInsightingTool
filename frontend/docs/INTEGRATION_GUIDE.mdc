# BrandBloom Insights - Modular Integration Guide

## ðŸŽ¯ Overview

This guide shows how to integrate and use the new modular structure in your applications. The modularization provides cleaner imports, better maintainability, and improved code organization.

## ðŸš€ Frontend Integration

### **Using the Modular Data Concatenation Component**

```typescript
// Old approach - single large component
import { DataConcatenationStep } from '@/components/steps/DataConcatenationStep';

// New modular approach - orchestrated component
import { DataConcatenationStepModular } from '@/components/steps/data-concatenation';

function MyPage() {
  return (
    <div>
      {/* Replace old component with new modular version */}
      <DataConcatenationStepModular />
    </div>
  );
}
```

### **Using Individual Custom Hooks**

```typescript
// Import specific hooks as needed
import { 
  useDataLoading, 
  useTargetVariable, 
  useFilterManagement 
} from '@/components/steps/data-concatenation/hooks';

function CustomComponent() {
  // Use data loading hook
  const { 
    loadingState, 
    concatenatedData, 
    loadExistingAnalysisData 
  } = useDataLoading();
  
  // Use target variable hook
  const { 
    selectedTargetVariable, 
    handleTargetVariableSelection 
  } = useTargetVariable({
    previewColumns,
    columnCategories,
    concatenatedData,
    originalFileName,
    concatenatedFileName,
    selectedSheets,
    totalRows,
    onAnalysisDataUpdate: (data) => {
      // Handle updates
    }
  });
  
  // Use filter management hook
  const { 
    selectedFilters, 
    handleFilterSelection 
  } = useFilterManagement({
    concatenatedData,
    columnCategories,
    originalFileName,
    concatenatedFileName,
    selectedSheets,
    selectedTargetVariable,
    totalRows,
    onAnalysisDataUpdate: (data) => {
      // Handle updates
    }
  });
  
  return (
    <div>
      {/* Use hook data in your component */}
      {loadingState.isLoading && <div>Loading...</div>}
      {selectedTargetVariable && <div>Target: {selectedTargetVariable}</div>}
      {selectedFilters.length > 0 && <div>Filters: {selectedFilters.join(', ')}</div>}
    </div>
  );
}
```

### **Using Shared Utilities**

```typescript
// Import shared utilities
import { httpClient, api } from '@/utils';
import { ENDPOINTS, validation, businessLogic } from '@/constants';

async function uploadFile(file: File) {
  try {
    // Use shared HTTP client
    const response = await httpClient.post(ENDPOINTS.FILES.UPLOAD, { file });
    
    // Use validation utilities
    if (!validation.isValidFileExtension(file.name)) {
      throw new Error('Invalid file extension');
    }
    
    if (!validation.isValidFileSize(file.size)) {
      throw new Error('File too large');
    }
    
    return response;
  } catch (error) {
    console.error('Upload failed:', error);
  }
}

function processBusinessLogic(steps: number[]) {
  // Use business logic utilities
  const progress = businessLogic.calculateProgress(steps.length);
  const nextStep = businessLogic.getNextRequiredStep(Math.max(...steps));
  
  return { progress, nextStep };
}
```

### **Using Modular Types**

```typescript
// Import specific types as needed
import type { 
  DataLoadingResult, 
  ConcatenationState, 
  PreviewDataRow,
  BrandCategories 
} from '@/components/steps/data-concatenation/types';

// Use types in your functions
function processData(data: PreviewDataRow[]): DataLoadingResult {
  return {
    success: true,
    data,
    columns: Object.keys(data[0] || {}),
    totalRows: data.length
  };
}

function updateState(state: ConcatenationState): void {
  // Type-safe state updates
  console.log(`Processing ${state.selectedSheets.length} sheets`);
}
```

## ðŸ”§ Backend Integration

### **Using Modular Excel Services**

```python
# Old approach - single large service
from app.services.excel_service import ExcelService

# New modular approach - specialized services
from app.services.excel import SheetConcatenator, PriceSheetGenerator, ColumnModifier

# Or use the modular orchestrator
from app.services.excel_service_modular import ExcelServiceModular

# Example usage
async def process_excel_file(filename: str, sheets: List[str]):
    try:
        # Use modular services directly
        concat_result = SheetConcatenator.concatenate_sheets(filename, sheets)
        
        if concat_result["success"]:
            # Generate price sheet
            price_df, created = PriceSheetGenerator.create_price_sheet(
                source_file_path, sheets
            )
            
            # Modify columns if needed
            mod_result = ColumnModifier.modify_excel_columns(filename, sheets)
        
        return concat_result
        
    except Exception as e:
        return {"success": False, "error": str(e)}

# Or use the orchestrator (maintains original API)
async def process_excel_orchestrated(filename: str, sheets: List[str]):
    return ExcelServiceModular.concatenate_sheets(filename, sheets)
```

### **Using Modular Analysis Services**

```python
# Old approach - single large service
from app.services.brand_analysis_service import BrandAnalysisService

# New modular approach - specialized services
from app.services.analysis import AnalysisManager, ProgressTracker, AnalysisLister

# Or use the modular orchestrator
from app.services.brand_analysis_service_modular import BrandAnalysisServiceModular

# Example usage
async def manage_analysis(analysis_id: str):
    try:
        # Use modular services directly
        analysis = AnalysisManager.get_analysis(analysis_id)
        
        if analysis["success"]:
            # Track progress
            current_step = ProgressTracker.calculate_current_step(
                analysis["analysis"]["progress"]
            )
            
            # Mark step complete
            ProgressTracker.mark_step_complete(analysis_id, "data_upload")
        
        return analysis
        
    except Exception as e:
        return {"success": False, "error": str(e)}

# Or use the orchestrator (maintains original API)
async def manage_analysis_orchestrated(analysis_id: str):
    return BrandAnalysisServiceModular.get_analysis(analysis_id)
```

### **Using Route Updates**

```python
# Update your routes to use modular services
from fastapi import APIRouter
from app.services.excel_service_modular import ExcelServiceModular
from app.services.brand_analysis_service_modular import BrandAnalysisServiceModular

router = APIRouter()

@router.post("/api/concatenate-sheets")
async def concatenate_sheets(request: ConcatenationRequest):
    """Use modular Excel service"""
    return ExcelServiceModular.concatenate_sheets(
        request.original_filename,
        request.selected_sheets,
        request.custom_filename,
        request.our_brand
    )

@router.get("/api/analyses")
async def list_analyses():
    """Use modular analysis service"""
    return BrandAnalysisServiceModular.list_analyses()
```

## ðŸ“ˆ Migration Strategy

### **Step 1: Gradual Migration**

```typescript
// Start by importing both old and new
import { DataConcatenationStep } from '@/components/steps/DataConcatenationStep';
import { DataConcatenationStepModular } from '@/components/steps/data-concatenation';

// Use feature flag or environment variable
const useModularComponents = process.env.REACT_APP_USE_MODULAR === 'true';

function MyComponent() {
  return useModularComponents ? 
    <DataConcatenationStepModular /> : 
    <DataConcatenationStep />;
}
```

### **Step 2: Test Individual Hooks**

```typescript
// Test hooks in isolation
import { useDataLoading } from '@/components/steps/data-concatenation/hooks';

function TestComponent() {
  const { loadingState, loadExistingAnalysisData } = useDataLoading();
  
  // Test the hook functionality
  useEffect(() => {
    if (analysisId && brandName) {
      loadExistingAnalysisData(analysisId, brandName);
    }
  }, [analysisId, brandName]);
  
  return <div>Testing hook: {loadingState.isLoading ? 'Loading...' : 'Ready'}</div>;
}
```

### **Step 3: Full Replacement**

```typescript
// Replace old components completely
// Remove old imports
// import { DataConcatenationStep } from '@/components/steps/DataConcatenationStep';

// Use new modular components
import { DataConcatenationStepModular } from '@/components/steps/data-concatenation';

function MyComponent() {
  return <DataConcatenationStepModular />;
}
```

## ðŸŽ¯ Benefits Realized

### **Code Reusability**
```typescript
// Hooks can be used in multiple components
import { useDataLoading } from '@/components/steps/data-concatenation/hooks';

// Use in different contexts
function ComponentA() {
  const { loadingState } = useDataLoading();
  // Use loading state
}

function ComponentB() {
  const { concatenatedData } = useDataLoading();
  // Use data
}
```

### **Better Testing**
```typescript
// Test individual hooks
import { renderHook } from '@testing-library/react-hooks';
import { useDataLoading } from '@/components/steps/data-concatenation/hooks';

test('useDataLoading hook', () => {
  const { result } = renderHook(() => useDataLoading());
  
  expect(result.current.loadingState.isLoading).toBe(false);
  expect(result.current.concatenatedData).toBe(null);
});
```

### **Easier Debugging**
```typescript
// Debug specific modules
import { loadLatestBrandData } from '@/components/steps/data-concatenation/services';

// Test service functions directly
async function debugDataLoading() {
  const result = await loadLatestBrandData('TestBrand');
  console.log('Data loading result:', result);
}
```

## ðŸš€ Best Practices

### **1. Import Only What You Need**
```typescript
// Good - specific imports
import { useDataLoading } from '@/components/steps/data-concatenation/hooks';
import { httpClient } from '@/utils';

// Avoid - importing everything
import * as DataConcatenation from '@/components/steps/data-concatenation';
```

### **2. Use Type Imports**
```typescript
// Good - type-only imports
import type { DataLoadingResult } from '@/components/steps/data-concatenation/types';

// Mixed imports
import { useDataLoading, type PreviewDataRow } from '@/components/steps/data-concatenation';
```

### **3. Leverage Barrel Exports**
```typescript
// Good - use barrel exports
import { useDataLoading, DataLoadingStatus } from '@/components/steps/data-concatenation';

// Avoid - deep imports when barrel exports exist
import { useDataLoading } from '@/components/steps/data-concatenation/hooks/useDataLoading';
```

This modular structure provides a clean, maintainable, and scalable architecture that will significantly improve your development experience! ðŸŽ‰
